# secure serializer

## Write-up

- Just like the [last challenge](../../serializer), the goal is to make the app deserialize to the following :

```python
if data == [1337, 1337.0, '1337', b'1337']:
      return render_template("index.html", flag=FLAG)
```

- But the problem now is that you need to provide a signature (md5 hash) of the serialized payload which is given when use the `Serialize` function

- The md5 signature is computed as the following : `md5(KEY || serialized)`, where `KEY` is a secret key of length 12 and `serialized` is our serialized object (python string in our case)

- The first issue to notice is that `md5(KEY || serialized)` is vulnerable to the hash length extension attack, where you can generate a valid hash for arbitrary input as long as the following conditions are met :
  - Knowing `md5(KEY || known_data)` : for example we can pass `A` to the serializer to get the signature, and the known_data in this case would the pickle serialization of `A` (`pickle.dumps("A")`)
  - Knowing the length of `KEY` : 12 (found in a comment under [serializer.py](../app/serializer.py))

- **Side note :** if you don't know how the hash length extension attack works, I shamelessly suggest reading [this write-up](https://github.com/malikDaCoda/CTFs-writeups/tree/master/crypto/TAMUctf%202020-Eternal%20Game) I made

- Using `hashpumpy`, let's try generating a payload so that the serialization of `[1337, 1337.0, '1337', b'1337']` is appended :

```python
from hashpumpy import hashpump
import pickle
import re
from binascii import unhexlify

def strip_pickle(p):
    # skip protocol
    s = re.sub(b'\x80.', b'', p)
    # skip stop instruction
    return re.sub(b'\\.', b'', s)

KEY_LENGTH = 12
data_to_add = pickle.dumps([1337, 1337.0, '1337', b'1337'])
known_data = strip_pickle(pickle.dumps('A'))
# from http://secure-serializer.web.ctf.microclub.net/serialize
signature = '27d24f35442f0ca2cc4aa0fb3df5370b'

result = hashpump(signature, known_data, data_to_add, KEY_LENGTH)
new_signature = result[0]
new_hexdata = result[1].hex()

print(new_signature)
# 4ad2c2e32dc23eab71b502f2e5d5477a
print(new_hexdata)
# 5801000000417100800000000000000000000000000000000000000000000000000000000000000000000000a00000000000000080035d7100284d3905474094e4000000000058040000003133333771014304313333377102652e
```

- When we pass those respective values we get a deserialization error instead of an invalid signature error, that means the hash lenght extension succeeded but the new payload cannot be deserialized by pickle

- To further investigate why it can't be deserialized, let's check locally with pickle.loads :

```python
new_hexdata = b'5801000000417100800000000000000000000000000000000000000000000000000000000000000000000000a00000000000000080035d7100284d3905474094e4000000000058040000003133333771014304313333377102652e'
# b"\x04" is protocol version
p = pickle.PROTO + b"\x04" + strip_pickle(unhexlify(new_hexdata)) + pickle.STOP
# p.hex() : 8004580100000041710000000000000000000000000000000000000000000000000000000000000000000000a0000000000000005d7100284d3905474094e4000000000058040000003133333771014304313333377102652e
print(pickle.loads(p))
```

- We get the following error : `UnpicklingError: invalid load key, '\x00'`

- Because of the padding null bytes added by `hashpump`, the serialized payload can't be parsed by pickle.loads

- The idea now is to craft `known_data` and `data_to_add` so that the actual deserialization happens smoothly

- Let's first try to minimize the number of null bytes :

```python
from hashpumpy import hashpump
import pickle
import re

def strip_pickle(p):
    # skip protocol
    s = re.sub(b'\x80.', b'', p)
    # skip stop instruction
    return re.sub(b'\\.', b'', s)

KEY_LENGTH = 12
data_to_add = pickle.dumps([1337, 1337.0, '1337', b'1337'])
known_data = strip_pickle(pickle.dumps('A' * 36))
# from http://secure-serializer.web.ctf.microclub.net/serialize
signature = '4d87d766b6183960c21c7c7179a86102'

result = hashpump(signature, known_data, data_to_add, KEY_LENGTH)
new_signature = result[0]
new_hexdata = result[1].hex()

print(new_signature)
# 700bef6fca70605df9a42d9d63f4268b
print(new_hexdata)
# 5824000000414141414141414141414141414141414141414141414141414141414141414141414141710080b80100000000000080035d7100284d3905474094e4000000000058040000003133333771014304313333377102652e
```

- Let's try deserializing the payload now :

```python
new_hexdata = b'5824000000414141414141414141414141414141414141414141414141414141414141414141414141710080b80100000000000080035d7100284d3905474094e4000000000058040000003133333771014304313333377102652e'
# b"\x04" is protocol version
p = pickle.PROTO + b"\x04" + strip_pickle(unhexlify(new_hexdata)) + pickle.STOP
# p.hex() : 800458240000004141414141414141414141414141414141414141414141414141414141414141414141417100010000000000005d7100284d3905474094e4000000000058040000003133333771014304313333377102652e
print(pickle.loads(p))
```

- Now we get the following error when trying to deserialize the new payload : `UnpicklingError: invalid load key, '\x01'`, and that's because of `01` byte not being a valid pickle instruction

- But we can notice in new_hexdata that `b801000000000000` represents the bit length of the hashed data in big endian notation, and that `01` byte is the one causing the unpickling error from before

- Since the block size for md5 is 64, we can keep minimizing the number of null bytes by having payloads of length `36 + 64 * X` where `X` is an integer we have control over

- And the reason that is important to mention is that since we control the bit length block by changing the length of our payload, we should try finding a valid `X` so that the bit length bytes are valid pickle deserialization instructions

- After some research about [pickle instructions](https://github.com/python/cpython/blob/main/Lib/pickle.py), we find the following instruction :

```python
BINFLOAT       = b'G'   # push float; arg is 8-byte float encoding
```

- This instruction pushes the next 8-byte float to the pickle stack, and since our bit length block should look something like `80 xx47000000000000` (`80` is not part of the bit length block of course), that means we already have 6 of those null bytes to consume, and we can add 2 more null bytes in data_to_append for a total of 8 dummy bytes, and finally append our payload for `[1337, 1337.0, '1337', b'1337']`

- After some calculations, we find that the required `X` should be 35

- Let's try our plan now with this solve script :

```python
#!/usr/bin/env python3

import pickle
from binascii import unhexlify
# python3 -m pip install hashpumpy
from hashpumpy import hashpump
from sys import argv, stderr, exit

KEY_LENGTH = 12
# serialization of : 'A' * (36+64*35)
KNOWN_DATA = b'X\xe4\x08\x00\x00AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq\x00'

data_to_add = b'\0\0' + pickle.dumps([1337, 1337.0, '1337', b'1337'])

if __name__ == "__main__":
    if len(argv) < 2:
        print(f"Usage: {argv[0]} SIGNATURE", file=stderr)
        exit(1)
    signature = argv[1]

    result = hashpump(signature, KNOWN_DATA, data_to_add, KEY_LENGTH)
    new_signature = result[0]
    new_hexdata = result[1].hex()

    print(f"[+] New signature : {new_signature}")
    print(f"[+] New hex data : {new_hexdata}")
```

- We pass `542cace9deeb2bf85edfea06e29bfe9b` as the signature argument since it's the signature returned after sending `'A' * (36 + 64*35)` as data, and we get the following :

```txt
[+] New signature : f70768f78b8300b95e6c4e704f3ed9a1
[+] New hex data : 58e40800004141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141710080b847000000000000000080035d7100284d3905474094e4000000000058040000003133333771014304313333377102652e
```

- Now finally, after passing the new signature and hexdata to the Deserialize function we get the flag : `shellmates{well_teCHn1CallY_i_D1DNt_Say_tH3_DESerIAL1ZeR_wAS_$ecur3}`

## Flag

`shellmates{well_teCHn1CallY_i_D1DNt_Say_tH3_DESerIAL1ZeR_wAS_$ecur3}`
